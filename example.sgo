// a simple function
func functionName() {}

// function with parameters (again, types go after identifiers)
func functionName2(param1 bool, param2 int) int {}

func main() {
	// assign a function to a name
	var add func(int, int) int = func(a int, b int) int {
		return a + b;
	};
	var showTrue func(int) = func(a int) {
		//print(a);
	};
	showTrue(8 - 5);
	// use the name to call the function
	print(add(3, 4));
}

// Closures, lexically scoped: Functions can access values that were
// in scope when defining the function
func scope() func() int {
	var outer_var int = 2;
	var foo func() int = func() int { return outer_var; };
	return foo;
}

// Closures: don't mutate outer vars, instead redefine them!
func outer() func() int {
	var outer_var int = 2;
	var inner func() int = func() int {
		outer_var += 99; // attempt to mutate outer_var from outer scope
		return outer_var;
	};
	print(inner()); // => 101 (but outer_var is a newly redefined
					//         variable visible only inside inner)
	return outer_var; // outer_var is still 2, not mutated by inner!
}

func conditions() {
	// Basic one
	if x > 0 {
		print(0);
	} else {
		print(1);
	}

	// Without else
	if x > 0 {
		print(true);
	}

	// Else if
	if x > 0 {
		print(1);
	} else if x == 0 {
		print(0);
	} else {
		print(-1);
	}
}

func loops() {
	// There's only `for`, no `while`, no `until`
	var i int = 20;
	for var i int = 1; i < 10; i++ {
	}
	for ; i < 10; { // while - loop
	}
	for i < 10 { // you can omit semicolons if there is only a condition
	}
	for { // you can omit the condition ~ while (true)
		print(10);
		break;
	}
}
